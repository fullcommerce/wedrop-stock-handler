"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const method_1 = __importDefault(require("../template/method"));
const createError_1 = __importDefault(require("../helpers/createError"));
const packErrorsToJsonApi_1 = __importDefault(require("../helpers/packErrorsToJsonApi"));
const handleApiError_1 = __importDefault(require("../helpers/handleApiError"));
class All extends method_1.default {
    all(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const entities = [];
            const params = {};
            const endpoint = this.endpoint || this.pluralName;
            const raw = options && options.raw !== undefined ? options.raw : this.raw;
            let hasMore = true;
            let reqCount = 0;
            let page = 1;
            let isSinglePage = false;
            if (options) {
                if (options.params) {
                    if (options.params.filters) {
                        const typedParams = options.params.filters;
                        const filters = Object.keys(options.params.filters)
                            .map((key) => typedParams[key] ? `${key}[${typedParams[key]}]` : null)
                            .filter((item) => !!item)
                            .join(';');
                        params.filters = filters;
                    }
                    if (options.params.infos) {
                        for (const infoKey in options.params.infos) {
                            params[infoKey] = options.params.infos[infoKey];
                        }
                    }
                }
                if (options.page) {
                    isSinglePage = true;
                    page = options.page;
                }
            }
            while (hasMore) {
                const response = yield this.api
                    .get(`/${endpoint}/page=${page}/json`, {
                    params
                })
                    .catch((err) => {
                    var _a, _b;
                    const errorData = {
                        name: 'BlingRequestError',
                        message: `Error on all method during request call: ${err.message}`,
                        status: String((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) || '400',
                        code: 'ERR_GET_REQUEST_FAILURE'
                    };
                    const rawData = (_b = err.response) === null || _b === void 0 ? void 0 : _b.data;
                    return (0, handleApiError_1.default)({
                        rawData,
                        errorData,
                        raw
                    });
                });
                const rawData = response.data;
                const responseData = rawData.retorno;
                if (responseData.erros) {
                    hasMore = false;
                    const pluralError = responseData;
                    const jsonApiErrorObj = (0, packErrorsToJsonApi_1.default)(pluralError);
                    // If there is an error different than 'not found'
                    if (jsonApiErrorObj.errors.some((err) => err.code !== '14')) {
                        const errorData = {
                            name: 'BlingRequestError',
                            message: 'Error on all method after request call',
                            status: '400',
                            code: 'ERR_ALL_METHOD_FAILURE'
                        };
                        if (raw) {
                            throw (0, createError_1.default)(Object.assign(Object.assign({}, errorData), { data: rawData }));
                        }
                        else {
                            throw (0, createError_1.default)(Object.assign(Object.assign({}, errorData), { data: jsonApiErrorObj }));
                        }
                    }
                }
                else {
                    const rawNewEntities = responseData;
                    const newEntities = rawNewEntities[this.pluralName];
                    const singularEntities = newEntities.map((item) => item[this.singularName]);
                    for (const entity of singularEntities) {
                        entities.push(entity);
                    }
                }
                if (isSinglePage) {
                    break;
                }
                page++;
                reqCount++;
                if (reqCount === 3) {
                    const sleep = new Promise((resolve) => {
                        setTimeout(resolve, 1000);
                    });
                    yield sleep;
                    reqCount = 0;
                }
            }
            if (raw) {
                return {
                    retorno: {
                        [this.pluralName]: entities.map((entity) => ({
                            [this.singularName]: entity
                        }))
                    }
                };
            }
            else {
                return entities;
            }
        });
    }
}
exports.default = All;
